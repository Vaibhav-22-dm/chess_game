<!DOCTYPE html>
<html>

<head>
    <title>Chess Game</title>
    <style>
        .board {
            width: 400px;
            height: 400px;
            display: flex;
            flex-wrap: wrap;
        }

        .square {
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 30px;
        }

        .white {
            background-color: #f0d9b5;
        }

        .black {
            background-color: #b58863;
        }

        .piece {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }

        .highlight {
            background-color: #93c572;
        }

        .red {
            background-color: #ff6c69;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="board">
            <div class="square white" data-row="0" data-col="0"></div>
            <div class="square black" data-row="0" data-col="1"></div>
            <div class="square white" data-row="0" data-col="2"></div>
            <div class="square black" data-row="0" data-col="3"></div>
            <div class="square white" data-row="0" data-col="4"></div>
            <div class="square black" data-row="0" data-col="5"></div>
            <div class="square white" data-row="0" data-col="6"></div>
            <div class="square black" data-row="0" data-col="7"></div>
            <div class="square black" data-row="1" data-col="0"></div>
            <div class="square white" data-row="1" data-col="1"></div>
            <div class="square black" data-row="1" data-col="2"></div>
            <div class="square white" data-row="1" data-col="3"></div>
            <div class="square black" data-row="1" data-col="4"></div>
            <div class="square white" data-row="1" data-col="5"></div>
            <div class="square black" data-row="1" data-col="6"></div>
            <div class="square white" data-row="1" data-col="7"></div>
            <div class="square white" data-row="2" data-col="0"></div>
            <div class="square black" data-row="2" data-col="1"></div>
            <div class="square white" data-row="2" data-col="2"></div>
            <div class="square black" data-row="2" data-col="3"></div>
            <div class="square white" data-row="2" data-col="4"></div>
            <div class="square black" data-row="2" data-col="5"></div>
            <div class="square white" data-row="2" data-col="6"></div>
            <div class="square black" data-row="2" data-col="7"></div>
            <div class="square black" data-row="3" data-col="0"></div>
            <div class="square white" data-row="3" data-col="1"></div>
            <div class="square black" data-row="3" data-col="2"></div>
            <div class="square white" data-row="3" data-col="3"></div>
            <div class="square black" data-row="3" data-col="4"></div>
            <div class="square white" data-row="3" data-col="5"></div>
            <div class="square black" data-row="3" data-col="6"></div>
            <div class="square white" data-row="3" data-col="7"></div>
            <div class="square white" data-row="4" data-col="0"></div>
            <div class="square black" data-row="4" data-col="1"></div>
            <div class="square white" data-row="4" data-col="2"></div>
            <div class="square black" data-row="4" data-col="3"></div>
            <div class="square white" data-row="4" data-col="4"></div>
            <div class="square black" data-row="4" data-col="5"></div>
            <div class="square white" data-row="4" data-col="6"></div>
            <div class="square black" data-row="4" data-col="7"></div>
            <div class="square black" data-row="5" data-col="0"></div>
            <div class="square white" data-row="5" data-col="1"></div>
            <div class="square black" data-row="5" data-col="2"></div>
            <div class="square white" data-row="5" data-col="3"></div>
            <div class="square black" data-row="5" data-col="4"></div>
            <div class="square white" data-row="5" data-col="5"></div>
            <div class="square black" data-row="5" data-col="6"></div>
            <div class="square white" data-row="5" data-col="7"></div>
            <div class="square white" data-row="6" data-col="0"></div>
            <div class="square black" data-row="6" data-col="1"></div>
            <div class="square white" data-row="6" data-col="2"></div>
            <div class="square black" data-row="6" data-col="3"></div>
            <div class="square white" data-row="6" data-col="4"></div>
            <div class="square black" data-row="6" data-col="5"></div>
            <div class="square white" data-row="6" data-col="6"></div>
            <div class="square black" data-row="6" data-col="7"></div>
            <div class="square black" data-row="7" data-col="0"></div>
            <div class="square white" data-row="7" data-col="1"></div>
            <div class="square black" data-row="7" data-col="2"></div>
            <div class="square white" data-row="7" data-col="3"></div>
            <div class="square black" data-row="7" data-col="4"></div>
            <div class="square white" data-row="7" data-col="5"></div>
            <div class="square black" data-row="7" data-col="6"></div>
            <div class="square white" data-row="7" data-col="7"></div>

            <!-- Add more squares for the complete chessboard -->
        </div>
        <div class="players">
            Current Player: <span class="current-player">white</span>
        </div>
        <div class="lost-pieces">
            <div>
                White: <span class="lost-pieces-white"></span>
            </div>
            <div>
                black: <span class="lost-pieces-black"></span>
            </div>
        </div>
        <div>
            <button class="new-game">New Game</button>
        </div>
    </div>


    <script>
        // Chess game logic
        const whites = ['♖', '♘', '♗', '♕', '♔', '♙']
        const blacks = ['♜', '♞', '♝', '♛', '♚', '♟']

        // Initial state of the chessboard
        let chessboard = [
            ['♜', '♞', '♝', '♛', '♚', '♝', '♞', '♜'],
            ['♟', '♟', '♟', '♟', '♟', '♟', '♟', '♟'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['♙', '♙', '♙', '♙', '♙', '♙', '♙', '♙'],
            ['♖', '♘', '♗', '♕', '♔', '♗', '♘', '♖']
        ];

        const validityFunctions = {
            '♖': isValidRookMove,
            '♜': isValidRookMove,
            '♘': isValidKnightMove,
            '♞': isValidKnightMove,
            '♗': isValidBishopMove,
            '♝': isValidBishopMove,
            '♕': isValidQueenMove,
            '♛': isValidQueenMove,
            '♔': isValidKingMove,
            '♚': isValidKingMove,
            '♙': isValidPawnMove,
            '♟': isValidPawnMove,
        }

        const currentPlayerSpan = document.querySelector('.current-player')
        const lostWhitePieces = document.querySelector('.lost-pieces-white')
        const lostBlackPieces = document.querySelector('.lost-pieces-black')

        // Track the currently selected square
        let selectedSquare = null;
        let currentPlayer = null;

        // Function to initialize the chessboard
        function initializeBoard() {
            const squares = document.querySelectorAll('.square');
            currentPlayer = 'white'

            for (let i = 0; i < squares.length; i++) {
                const square = squares[i];
                const row = parseInt(square.getAttribute('data-row'));
                const col = parseInt(square.getAttribute('data-col'));

                // Set the piece on the square
                const piece = chessboard[row][col];
                square.textContent = piece;

                // Add event listener to the square
                square.addEventListener('click', () => selectSquare(row, col));
            }
        }

        function startGame() {
            chessboard = [
                ['♜', '♞', '♝', '♛', '♚', '♝', '♞', '♜'],
                ['♟', '♟', '♟', '♟', '♟', '♟', '♟', '♟'],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['♙', '♙', '♙', '♙', '♙', '♙', '♙', '♙'],
                ['♖', '♘', '♗', '♕', '♔', '♗', '♘', '♖']
            ]

            let squares = document.querySelectorAll('.square')

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    squares[i * 8 + j].innerHTML = chessboard[i][j];
                }
            }

            currentPlayerSpan.innerHTML = 'white'
            lostBlackPieces.innerHTML = ''
            lostWhitePieces.innerHTML = ''
            currentPlayer = 'white'

            initializeBoard()
        }

        document.querySelector('.new-game').addEventListener('click', startGame);



        // Function to select a square and show possible moves
        function selectSquare(row, col) {
            const square = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);

            document.querySelectorAll(".square").forEach(item => {
                item.classList.remove("highlight")
                item.classList.remove("red")
            })

            square.classList.add('highlight');

            if (selectedSquare === null) {
                if (square.textContent === "") {
                    alert("Please select square with a piece")
                    square.classList.remove('highlight');
                }
                else {
                    if (isOpponentPiece(square.textContent)) {
                        alert("You can't move opponent's piece")
                        square.classList.remove('highlight');
                    }
                    else {
                        // show possible moves
                        selectedSquare = square
                        square.classList.add('red')
                        highlightValidMoves(square.textContent, row, col)
                    }
                }
            }
            else {
                const selectedRow = parseInt(selectedSquare.getAttribute('data-row'));
                const selectedCol = parseInt(selectedSquare.getAttribute('data-col'));


                if (square.textContent !== "" && !isOpponentPiece(square.textContent)) {
                    // If player selects another piece
                    selectedSquare = square
                    square.classList.add('red')
                    highlightValidMoves(square.textContent, row, col)
                }
                else {
                    // Check if the move is valid
                    if (isValidMove(selectedRow, selectedCol, row, col)) {
                        // Move the piece to the new square
                        chessboard[row][col] = chessboard[selectedRow][selectedCol];
                        chessboard[selectedRow][selectedCol] = '';

                        // Update lost pieces
                        if (isOpponentPiece(square.textContent)) {
                            document.querySelector(`.lost-pieces-${currentPlayer === 'white' ? 'black' : 'white'}`).innerHTML += square.textContent;
                        }

                        // Update the UI
                        square.textContent = chessboard[row][col];
                        selectedSquare.textContent = '';

                        // Reset the selected square
                        selectedSquare = null;

                        currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
                        currentPlayerSpan.innerHTML = currentPlayer

                        // Check for checkmate or stalemate
                        if (isCheckmate()) {
                            alert('Checkmate!');
                            // Implement any game-ending logic here
                            startGame()
                        }
                        else if (isStalemate()) {
                            alert('Stalemate!');
                            // Implement any game-ending logic here
                            startGame()
                        }
                        square.classList.remove('highlight');
                    } else {
                        // Invalid move
                        alert('Invalid move!');
                        square.classList.remove('highlight');
                    }
                }
            }

        }

        // Function to check if a piece belongs to the opponent
        function isOpponentPiece(piece) {
            // Implement your logic to check the color of the piece

            if (
                (currentPlayer === 'white' && blacks.includes(piece)) ||
                (currentPlayer === 'black' && whites.includes(piece))
            ) {
                return true;
            }
            else {
                return false;
            }
        }

        // Function to check if a move is valid
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            const piece = chessboard[fromRow][fromCol];
            const target = chessboard[toRow][toCol];

            // Piece can't move to its own location
            if (fromRow == toRow && fromCol == toCol) return false;

            // User can't move a piece to a place where it's own piece is present
            if (target !== '') {
                const fromColor = whites.includes(piece) ? 'white' : 'black';
                const toColor = whites.includes(target) ? 'white' : 'black';
                if (fromColor === toColor) {
                    return false;
                }
            }

            return validityFunctions[piece](fromRow, fromCol, toRow, toCol)
        }

        // Function to check if a rook move is valid
        function isValidRookMove(fromRow, fromCol, toRow, toCol) {

            // const color = whites.includes(chessboard[fromRow][fromCol]) ? 'white' : 'black';
            // const target = whites.includes(chessboard[toRow][toCol]) ? 'white' : 'black';

            // Check if the move is horizontal or vertical
            if (fromRow === toRow || fromCol === toCol) {
                // Check if there are any pieces in the way
                if (fromRow === toRow) {
                    const start = Math.min(fromCol, toCol) + 1;
                    const end = Math.max(fromCol, toCol);

                    for (let col = start; col < end; col++) {
                        if (chessboard[fromRow][col] !== '') {
                            return false;
                        }
                    }
                } else {
                    const start = Math.min(fromRow, toRow) + 1;
                    const end = Math.max(fromRow, toRow);

                    for (let row = start; row < end; row++) {
                        if (chessboard[row][fromCol] !== '') {
                            return false;
                        }
                    }
                }

                return true;
            }

            return false;
        }

        // Function to check if a knight move is valid
        function isValidKnightMove(fromRow, fromCol, toRow, toCol) {
            // Check if the move is L-shaped
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);

            return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2)
        }

        // Function to check if a bishop move is valid
        function isValidBishopMove(fromRow, fromCol, toRow, toCol) {

            // Check if the move is diagonal
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);

            if (rowDiff === colDiff && (rowDiff > 0 || colDiff > 0)) {
                // Check if there are any pieces in the way
                const rowDir = toRow > fromRow ? 1 : -1;
                const colDir = toCol > fromCol ? 1 : -1;
                let row = fromRow + rowDir;
                let col = fromCol + colDir;
                while (row !== toRow && col !== toCol) {
                    if (chessboard[row][col] !== '') {
                        return false;
                    }

                    row += rowDir;
                    col += colDir;
                }

                return true;
            }

            return false;
        }

        // Function to check if a queen move is valid
        function isValidQueenMove(fromRow, fromCol, toRow, toCol) {
            // Queen move is valid if it's a valid rook move or a valid bishop move
            return isValidRookMove(fromRow, fromCol, toRow, toCol) || isValidBishopMove(fromRow, fromCol, toRow, toCol);
        }

        // Function to check if a king move is valid
        function isValidKingMove(fromRow, fromCol, toRow, toCol) {
            // Check if the move is one square away horizontally, vertically, or diagonally
            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);

            return ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1) || (rowDiff === 1 && colDiff === 1))
        }

        // Function to check if a pawn move is valid
        function isValidPawnMove(fromRow, fromCol, toRow, toCol) {

            const piece = chessboard[fromRow][fromCol];
            const target = chessboard[toRow][toCol];

            const direction = whites.includes(piece) ? -1 : 1;

            // Check if it's a valid pawn move one square forward
            if (fromCol === toCol && toRow === fromRow + direction && target === '') {
                return true;
            }

            // Check if it's a valid pawn move two squares forward from the starting position
            if (
                (
                    (direction === -1 && fromRow === 6) ||
                    (direction === 1 && fromRow === 1)
                ) &&
                fromCol === toCol &&
                toRow === fromRow + (2 * direction) &&
                target === '' &&
                chessboard[fromRow + direction][fromCol] === ''
            ) {
                return true;
            }

            // Check if it's a valid pawn capture move
            if (Math.abs(toCol - fromCol) === 1 && toRow === fromRow + direction && target !== '') {
                return true;
            }

            return false;
        }


        // Function to check for checkmate
        function isCheckmate() {
            // Find the positions of both kings
            let kingPosition = null;

            let pieces = []

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (
                        chessboard[row][col] !== '' &&
                        (
                            currentPlayer === 'white' && whites.includes(chessboard[row][col]) ||
                            currentPlayer === 'black' && blacks.includes(chessboard[row][col])
                        )
                    ) {
                        pieces.push([chessboard[row][col], row, col])
                    }

                    if (
                        (currentPlayer === 'black' && chessboard[row][col] === '♚') ||
                        (currentPlayer === 'white' && chessboard[row][col] === '♔')
                    ) {
                        kingPosition = {
                            row: row,
                            col: col
                        }
                    }
                }
            }

            // Check if the white king is in check
            if (isKingThreatened(kingPosition)) {
                // Check if the current player has any valid move that can remove the check
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        for (let i = 0; i < pieces.length; i++) {
                            if (isValidMove(pieces[i][1], pieces[i][2], row, col)) {
                                let x = chessboard[row][col];
                                let y = chessboard[pieces[i][1]][pieces[i][2]]
                                let z = kingPosition
                                chessboard[row][col] = chessboard[pieces[i][1]][pieces[i][2]];
                                chessboard[pieces[i][1]][pieces[i][2]] = '';

                                if (pieces[i][0] === '♔' || pieces[i][0] === '♚') {
                                    kingPosition = {
                                        row: row,
                                        col: col
                                    }
                                }
                                let newState = isKingThreatened(kingPosition)

                                chessboard[row][col] = x;
                                chessboard[pieces[i][1]][pieces[i][2]] = y;
                                kingPosition = z;

                                if (!newState) {
                                    return false;
                                }
                            }
                        }
                    }
                }

                return true; // No move can remove the check, it's checkmate
            }

            return false; // White king is not in checkmate
        }

        // Function to check for stalemate
        function isStalemate() {

            // Getting position of all the pieces of the current player
            let pieces = []

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (
                        chessboard[row][col] !== '' &&
                        (
                            currentPlayer === 'white' && whites.includes(chessboard[row][col]) ||
                            currentPlayer === 'black' && blacks.includes(chessboard[row][col])
                        )
                    ) {
                        pieces.push([chessboard[row][col], row, col])
                    }
                }
            }

            // Going through all the squares present on the chess board
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    // Checking if any piece of the current player can move to this particular square
                    for (let i = 0; i < pieces.length; i++) {
                        if (isValidMove(pieces[i][1], pieces[i][2], row, col)) {
                            return false
                        }
                    }
                }
            }

            return true; // No valid moves available, it's stalemate
        }

        // Function to check if the king is threatened
        function isKingThreatened(kingPosition) {

            // Getting position of all the pieces of the opponent player
            let pieces = []

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (
                        chessboard[row][col] !== '' &&
                        (
                            currentPlayer === 'white' && blacks.includes(chessboard[row][col]) ||
                            currentPlayer === 'black' && whites.includes(chessboard[row][col])
                        )
                    ) {
                        pieces.push([chessboard[row][col], row, col])
                    }
                }
            }

            let opponentMoves = []

            // Going through all the squares present on the chess board
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    // Checking if any piece of the current player can move to this particular square
                    for (let i = 0; i < pieces.length; i++) {
                        if (isValidMove(pieces[i][1], pieces[i][2], row, col)) {
                            // Checking if the valid move is a capture move or not
                            if (chessboard[row][col] !== "") {
                                opponentMoves.push([row, col])
                            }
                        }
                    }
                }
            }

            // Check if the king's position is in the opponent's moves
            for (let move of opponentMoves) {
                if (move[0] === kingPosition.row && move[1] === kingPosition.col) {
                    return true; // King is threatened
                }
            }

            return false; // King is not threatened
        }

        function highlightValidMoves(piece, row, col) {

            const highlightedSquares = document.querySelectorAll('.highlight');
            highlightedSquares.forEach(item => item.classList.remove('highlight'));

            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    const validity = isValidMove(row, col, i, j)
                    if (validity) {
                        const square = document.querySelector(`.square[data-row="${i}"][data-col="${j}"]`);
                        square.classList.add('highlight');
                    }
                }
            }
        }


        // Initialize the chessboard
        initializeBoard();
    </script>
</body>

</html>